pudl.dbt_wrapper
================

.. py:module:: pudl.dbt_wrapper

.. autoapi-nested-parse::

   Wrap DBT invocations so we can get custom behavior.



Attributes
----------

.. autoapisummary::

   pudl.dbt_wrapper.logger
   pudl.dbt_wrapper.DBT_DIR


Classes
-------

.. autoapisummary::

   pudl.dbt_wrapper.NodeContext
   pudl.dbt_wrapper.BuildResult


Functions
---------

.. autoapisummary::

   pudl.dbt_wrapper.__get_failed_nodes
   pudl.dbt_wrapper.__get_quantile_contexts
   pudl.dbt_wrapper.__get_compiled_sql_contexts
   pudl.dbt_wrapper.build_with_context
   pudl.dbt_wrapper.dagster_to_dbt_selection


Module Contents
---------------

.. py:data:: logger

.. py:data:: DBT_DIR
   :type:  pathlib.Path

.. py:class:: NodeContext

   Bases: :py:obj:`NamedTuple`


   Associate a node's *name* with information describing what went wrong.


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: context
      :type:  str


   .. py:method:: pretty_print()

      Nice output for logging to stdout.



.. py:class:: BuildResult

   Bases: :py:obj:`NamedTuple`


   Combine overall result with any useful failure context.


   .. py:attribute:: success
      :type:  bool


   .. py:attribute:: failure_contexts
      :type:  list[NodeContext]


   .. py:method:: format_failure_contexts() -> str

      Nice legible output for logs.



.. py:function:: __get_failed_nodes(results: dbt.artifacts.schemas.run.RunExecutionResult) -> list[dbt.contracts.graph.nodes.GenericTestNode]

   Get test node output from tests that failed.


.. py:function:: __get_quantile_contexts(nodes: list[dbt.contracts.graph.nodes.GenericTestNode], dbt: dbt.cli.main.dbtRunner, dbt_dir: pathlib.Path) -> list[NodeContext]

   Run debug_quantile_constraints macro for failed quantile constraints.

   This is a little tricky because the macro output is just logged to
   stdout, and not stored in the dbt.invoke result. So, for each node, we:

   * redirect stdout
   * run the macro based on node information
   * parse stdout to get the context

   Also, if a node has multiple parents, we don't know which table to pass into
   ``debug_quantile_constraints`` so we just skip it.


.. py:function:: __get_compiled_sql_contexts(nodes: list[dbt.contracts.graph.nodes.GenericTestNode]) -> list[NodeContext]

   Run the compiled SQL against duckdb to get failure contexts.


.. py:function:: build_with_context(node_selection: str, dbt_target: str, node_exclusion: str | None = None) -> BuildResult

   Run the DBT build and get failure information back.

   * run the DBT build using our selection, returning test failures
   * split the test failures by type - for most, we will just run the compiled
     SQL, but other tests such as the weighted quantile tests need extra
     handling
   * get contexts for various test failure types
   * print out test failure context


.. py:function:: dagster_to_dbt_selection(selection: str, defs: dagster.Definitions | None = None, manifest=None) -> str

   Translate dagster asset selection to db node selection.

   We use the dbt manifest to determine which sources are defined in dbt so
   that we can map them to dagster assets. So, we need to generate a fresh dbt
   manifest via ``dbt parse`` whenever we run this function.

   * turn asset selection into asset keys
   * turn asset keys into node names
   * turn node names into selection string


